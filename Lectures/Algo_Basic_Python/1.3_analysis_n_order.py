'''
1.3 알고리즘의 분석

* 어떤 알고리즘에 대한 두가지 중요한 질문
    1) 정확한가 : 모든 input에 대해 해답이 있는가. 증명가능해야함.
    2) 효율적인가 : input size가 커지면 성능이 어떻게 변화나는가?

* 알고리즘의 분석
    : 1, 2 를 증명하는 것을 알고리즘 분석이라고 한다.
    1. 정확성 분석 : 귀납적증명
    2. 효율성 분석
        - 시간복잡도
        - 공간복잡도

* 알고리즘의 성능분석
    - 퍼포먼스 분석 : 컴퓨터의 성능이나 프로그래밍 언어에 따라 달라짐
    - 복잡도 분석 : 컴퓨터나 언어와 무관하게 성능분석
                입력크기에 따른 단위연산의 실행 횟수 세기!

* 복잡도 분석
    - 입력크기 : 문제가 가진 파라미터, 즉 입력 사례의 크기(n)
    - 단위연산 : 알고리즘 실행의 기본이 되는 명령어들의 집합
'''

'''
    ex)  [배열원소의 합]의 시간복잡도 분석
        - 단위연산 : 리스트의 원소를 result에 더하는 명령
        - 입력크기 : 리스트 S의 원소의 개수(n)
        - for 문장은 항상 n번 실행하므로 다음과 같이 표현
        - 시간복잡도 T(n) = n
'''
def sum (S) :
    n = len(S)
    result = 0
    for i in range(n):
        result += S[i]
    return result
'''
    ex) [교환정렬]의 시간복잡도 분석
        - 단위연산 : S[i]와 S[j]의 비교하는 연산 (swap작업을 단위로두지않는다)
        - 입력크기 : 정렬할 리스트S의 원소 개수 n
        - for-j 루프는 i에 따라 n-1번에서 1번까지 실행하므로 다음과 같이 계산
        - 시간복잡도 T(n) = (n-1)+(n-2)+...+1 = (n-1)*n/2 = 
 '''
def exchange (S) :
    n = len(S)
    for i in range(n-1):
        for j in range(i+1, n):
            if (S[i]>S[j]):
                S[i], S[j] = S[j], S[i] #swap

'''

* 단위 연산의 실행 횟수는 항상 일정한가?
    - 순차탐색의 경우 입력사례에 따라 다름
    
* 입력사례에 따른 시간복잡도 분석
    - 일정 시간복잡도 : 입력 사례에 따라 달라지지 않는경우.
    - 최악, 최적, 평균 시간복잡도 : 입려사례에 따라 달라지는경우.
        : 보통 최악, 평균 시간복잡도를 중요 시 여김
'''
