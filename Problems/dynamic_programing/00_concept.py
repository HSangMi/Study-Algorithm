# DP01 다이나믹 프로그래밍이란?
# https://www.youtube.com/watch?v=bzfm8SO4j9I&list=PLN3yisVKGPfhmFpkSEwsWZOZDJ3UUojEA&index=2&ab_channel=IOIKOREA
'''
다이나믹 프로그래밍 : 알고리즘 x, 접근방식 O
    - 점화식
    - 큰 문제를 작은문제를 사용해 해결하는 방법
    - 과거에 구한 해를 활욯하는 방법
    - 메모이제이션
    => 재귀적으로 생각하기 + 불필요한 계산 줄이기

재귀적이란?
    := 귀납적 ( 작은 문제는 해결되어 있다는 믿음을 가지고 큰 문제를 해결하는 방법 )

    1 + 3 + 5 + ... + (2n-1) = n^2

    1) n=1 일떄 참이고
    2) n=k 가 참이라고 가정했을때
    3) n=k+1 일때도 참이라면, 해당 명제는 참

    ex) 피보나치수열
    f0 = 1,
    f1 = 1,
    f(n) = f(n-1) + f(n-2)
    => 이것을 그냥 구현하게 되면 불필요한 계산이 너무 많음!!
    => 이것을 해결하기위한 기법이
    => 1. '메모이제이션' => 이미 했던 계산은 다시하지 않는다.
    => 2. 밑에서부터 계산하기

'''


# 피보나치
def fibo(n):
    if n == 0: return 1
    if n == 1: return 1
    return fibo(n - 1) + fibo(n - 2);


# 피보나치 + 메모이제이션
memo = [0] * 10000


def fibo1(n):
    if n == 0: return 1
    if n == 1: return 1
    if memo[n] != 0: return memo[n]
    memo[n] = fibo1(n - 1) + fibo1(n - 2);
    return memo[n];


# 피보나치 + 밑에서부터 계산하기

fi = [0] * 1000


def fibo2(n):
    fi[0] = 1
    fi[1] = 1
    for i in range(2, 1000):
        fi[i] = fi[i - 1] + fi[i - 2]


# DP2 상태 표현하기
# https://www.youtube.com/watch?v=bzfm8SO4j9I&t=174s&ab_channel=IOIKOREA
'''
    다이나믹 프로그래밍 
    = 재귀적으로 생각하기 (작은문제와 큰문제로 나누고 관계 정의하기 ★★★)
        +
      불필요한 계산줄이기(메모리제이션 or 밑에서부터계산하기 - 기술적문제)
      
    * 부분문제 정의하기
        : 작은문제를 이용해서 큰 문제를 풀기위해서는 충분한 정보를 기억해야함!
            -> 상태표현
        
        예제1)   n개의 계단을 오르려고 한다.
                한 번에 1개의 계단을 오르거나, 2개의 계단을 오를 수 있을 때,
                계단을 오를 수 있는 경우의 수는?
                
                부분문제 : 계단 i개를 오를 떄의 경우의 수 f(i)
                          f(i) = i-1 에서 한칸 + i-2에서 두칸 오를 경우의수
                          즉, f(i) = f(i-1) + f(i-2)
                          
        + 추가 조건 ( 단, 연속된 세개의 계단을 모두 밟아서는 안된다 )이 있는경우
            점화식을 만들기엔 정보가 부족!!
            + 더 필요한 정보는 무엇일까?
                : 지금까지 거쳐온 계단의 목록을 알고있으면 된다 !
                => 현재 i개의 계단을 올라왔고, 지금까지 집합S에 있는 계단들을 거쳐왔을 때,
                => 고려할 부분정보가 너무 많음!!!
                
                기억해야하는 정보의 수는 풀이의 '시간복잡도'와 밀접한 연관이 있음
                현재 상태를 나타내기 위해 필요한 '최소의 정보'만 기억하는것이 중요!
                
                더 필요한, 최소의 정보는?? : 지금까지 연속으로 오른 계단의 수 j !
                
                부분문제 : i개의 계단을 올랐고, 현재 연속해서 j번째 계단일 때,
                f(i,2) = f(i-1, 1)
                f(i-1) = f(i-1, 0) +( f(i-2.0)+f(i-2,1) + f(i-2,2) )
                f(i,0) = (i==0)일 경우에만 1 아니면 0
                
                => 작은문제와 큰문제 관계를 명확히 정의!!
                
                즉, 작은 부분문제로 큰 부분문제를 해결하기 위해서는
                충분한 정보를 기억해야한다.
                한편, 기억해야 할 정보의 수가 너무 많으면, 
                효율적인 풀이를 만들기 어려우므로 최소한의 정보만 기억해야한다.


'''
# DP3 트리 위에서의 DP
# https://www.youtube.com/watch?v=a-cjNNPaJCo&ab_channel=IOIKOREA
'''
    예제) n개의 정점을 가진 트리가 입력된다.
         트리에서는 두 정점 u,v사이 경로가 유일하다.
         
         트리 지름이란 모든 두 정점 쌍(u,v)에 대해서 u,v 사이 경로의 길이 중
         최댓값을 의미한다. 트리의 지름을 구하라
         
        트리 = 서브트리+서브트리
        
        D[v] : v 아래 서브트리의 지름
        자식 서브트리 D값으로 (작은문제)
        나의 D값을 채울 수 있을까?(큰문제)
        
        => 어려움! : 추가조건 필요!
                   [v]
               w1/  |w2 \w3
             [c1]  [c2]  [c3]
             
             정점 v를 지나는 경로는 자식 2개를 통과하거나, 자식1개를 통과하는 경로
             
             1) 자식 2개를 통과하는경우
                : 정점v를 지나고 자식 ci, cj를 지나는 가장 긴 경로가 필요
                E[ci] = (ci의 서브트리에서 ci와 가장 먼 정점까지의 거리)
                
             2) 자식 1개를 통과하는 경우
                : 정점 v에서 시작해서 자식ci를 지나는 가장 긴 경로가 필요
                E[ci] = (ci의 서브트리에서 ci와 가장 먼 정점까지의 거리
                
                ∴ D[v] = max(D[c1,D[c2],...D[ck],
                                (wi+E[ci] 중 가장 큰 2개의 합),
                                (wi+E[ci] 중 가장 큰 1개의 합)  )
                                
                                    E[v] = max(wi+E[ci])
                
        DP를 적용하기 위해선, 큰문제를 해결하려는 시점에 이미 작은 문제가 해결이 되어 있어야함.
        즉, 문제를 해결하는 모종의 순서가 있어야함
        
        서브트리로 부분문제를 만든 경우 현재 정점에서의 문제를 풀기 위해서는 자식정점에서의 문제가 다 풀려있어야함
        
        이런 순서로 문제를 풀기위해서는 'DFS 종료 순서'를 활용할 수 있다.
        
                
    
'''
