# BOJ 2003 :
# 수들의 합 2
#   N개의 자연수를 갖는 수열에서 연속 구간의 합이 M이 되는 수 경우의 수 찾기
#   ex) N=10, M=5
#   ->포인터 2개가 같은방향으로 진행하는 것
'''
풀이
    M=5, SUM=10
    A [1][2][3][4][2][5][3][1][1][2]
    L := 연속 구간의 왼쪽 끝 후보
    R := 연속 구간의 오른쪽 끝 후보
    SUM := 현재 연속 구간의 합

    1. SUM < M인 상황
        => SUM 이 더 커져야 하는상황 =>  R이 더 오른쪽으로 가야 하는 상황
    2. SUM > M인 상황
        => SUM 이 더 작아져야 하는 상황 => L이 더 오른쪽으로 가야 하는 상황
    3. SUM == M인 상황
        => L부터 R까지의 합이 M인 순간! => 더이상 현재 L을 볼 필요가 없으므로 L을 오른쪽으로 이동
    위를 반복 하면, SUM과 M의 사이의 관계를 통해서 L과 R이 연속구간의 끝인 경우를 모두 찾는다

    총 시간복잡도는 SUM과 M을 비교하는 횟수,
    즉, L과 R포인터가 움직인 횟수와 같다 (최대 2N -> O(N))
'''


def BOJ_2003(n, m, A):
    sum = 0
    cnt = 0
    R = 0
    for L in range(n):
        # xxxxx sum += A[L] : 같은데에서 시작하니까 더하는건 R만!!
        # sum < m 라면 더 더하고, 크거나 같으면 그만 더함
        while sum < m and R < n:  # sum>m는 의미가없으니깐!
            sum += A[R]
            R += 1
        # 같으면 카운트 증가
        if sum == m:
            cnt += 1
            # L을 오른쪽으로 이동-> for 문에서 해주지롱
            sum - A[L]  # L을 한칸이동하니까 그 전값은 빼주기!
    print(cnt)

# data = [1, 2, 3, 4, 2, 5, 3, 1, 1, 2]
# BOJ_2003(5, 10, data)